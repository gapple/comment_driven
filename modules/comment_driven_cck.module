<?php
// $Id$

/**
 * Implements hook_form_alter().
 */
function comment_driven_cck_form_alter(&$form, &$form_state, $form_id) {
  // can't use hook_form_FORM_ID_alter,
  // since we want our submit handler to be invoked
  // after fieldgroup_field_overview_form_submit (which is added in form_alter time) 
  if ($form_id != 'content_field_overview_form') return;

  $form['#submit'][] = 'comment_driven_cck_field_overview_form_submit';
}

/**
 * Auto-detect and fix changed property paths due to fields being moved into/out from/to a different group. 
 */
function comment_driven_cck_field_overview_form_submit($form, &$form_state) {
  // this function is only intended to babysit site-builders a little more
  // but restless site-builders will hit the cross-posting pitfalls anyway
  // having following two forms opened at the same time
  // - admin/content/node-type/[type]
  // - admin/content/node-type/[type]/fields
  // once the fields are moved between groups/no-group
  // the content type edition form reflects an inaccurate list of available properties
  // (and even refreshing it won't be enough in those wise browsers which leave checked checkboxes)
  // BUT this is support enough to those site-builders just moving a field around
  
  $node_type = $form['#type_name'];
  $field_names = $form['#fields'];
  // if fieldgroup module is not enabled we still process the overview form
  // because it might got recently disabled
  // which would be the same as taking every property out of its group
  if (module_exists('fieldgroup')) {
    // clear fieldgroup static cache
    fieldgroup_groups($node_type, FALSE, TRUE);
  }
  
  // read property paths without limiting them to available properties
  // (editing node_form structure is an exclusive feature of CCK)
  $unfiltered_property_paths = comment_driven_get_property_paths($node_type, FALSE);
  $old_property_paths = array();
  foreach ($unfiltered_property_paths as $property_path) {
    $path_parts = explode(':', $property_path);
    // if it is a CCK field its old property path will be either:
    // - field_name
    // - group_name:field_name
    $field_name = array_pop($path_parts);
    if (strpos($field_name, 'field_') !== 0) {
      // not a field_name
      continue;
    }
    // group_name is not needed
    //$group_name = empty($path_parts) ? '' : array_shift($path_parts);
    
    // remember that it might not be a field even when its name matches the pattern
    $old_property_paths[$field_name] = $property_path;
  }
  
  $updated = FALSE;
  $available_cck_properties = comment_driven_cck_driven_properties($node_type);
  foreach ($available_cck_properties as $property_path => $prop) {
    $field_name = $prop['meta']['field_name'];
    // if we can't find it might be moved (under a different group or no group at all)
    if (isset($old_property_paths[$field_name]) && !in_array($property_path, $unfiltered_property_paths)) {
      $old_property_path = $old_property_paths[$field_name];
      // we found it under its old property path, lets update it
      if (in_array($old_property_path, $unfiltered_property_paths)) {
        // remove the old property path
        $unfiltered_property_paths = array_diff($unfiltered_property_paths, array($old_property_path));
        // add the new property path
        $unfiltered_property_paths[] = $property_path;
        
        $updated = TRUE;
        watchdog('comment_driven', t('Driven property path was moved from %old_path to %new_path'), array('%old_path' => $old_property_path, '%new_path' => $property_path), WATCHDOG_INFO);
      }
    }
  }
  if ($updated) {
    // reset indexes (just in case someone expect them being sequential)
    $unfiltered_property_paths = array_values($unfiltered_property_paths);
    // update the unfiltered property paths
    variable_set('comment_driven:properties_' . $node_type, $unfiltered_property_paths);
  }
}

/**
 * Implements hook_driven_properties().
 */
function comment_driven_cck_driven_properties($node_type) {
  $available_props = array();
  
  $prefix = t('CCK') . ' » ';
  
  // according to content_field_overview_form:
  // When displaying the form, make sure the list of fields is up-to-date.
  content_clear_type_cache();
  
  // Gather type information.
  $cck_type = content_types($node_type);
  $fields = $cck_type['fields'];
  $field_types = _content_field_types();
  
  $groups = array();
  if (module_exists('fieldgroup')) {
    $groups = fieldgroup_groups($cck_type['type']);
  }
  
  $grouped_paths = array();
  // first lookup the groups to discriminate nested fields
  foreach ($groups as $group_name => $group) {
    foreach ($group['fields'] as $field_name => $field) {
      $grouped_paths[$field_name] = $group_name;
    }
  }

  // lookup fields withtout group
  foreach ($fields as $field_name => $field) {
    // pack info for later use
    $meta = compact('node_type', 'field_name');
  
    if (isset($grouped_paths[$field_name])) {
      $group_name = $grouped_paths[$field_name];
      $group_path_prefix = $group_name . ':';
      $group_title_prefix = $group_name . ' » ';
    }
    else {
      $group_name = NULL;
      $group_path_prefix = '';
      $group_title_prefix = '';
    }
    
    $available_props[$group_path_prefix . $field_name] = array(
      'realm' => 'cck',
      'meta' => $meta,
      'type_settings' => array(
        '#title' => $prefix . $group_title_prefix . $field['widget']['label'],
/*
        // the more elemental the lighter
        // (core required: -5, core optional: -2, CCK: 1, CCK submod: 2)
        '#weight' => 1,
*/
      ),
    );
    
    $supported_modules = array(
      'userreference', 
      'nodereference', 
      'number', 
      'text', 
      'optionwidgets', 
      'filefield', 
      'date',
      // this would be enough to support vanilla content_taxonomy
      // which uses CCK-related widgets (content_taxonomy_optionwidgets & content_taxonomy_autocomplete)
      // but it isn't enough to support its taxonomy-related widgets (e.g. hs_content_taxonomy)
      'content_taxonomy',
    );
    if (!in_array($field['module'], $supported_modules)) {
      $available_props[$group_path_prefix . $field_name]['type_settings'] += array(
        '#description' => t('Pending %module support.', array('%module' => $field['module'])),
        '#disabled' => TRUE,
        '#value' => FALSE,
        '#weight' => 10, // sink
      );
    }
    
    // @per-module-discrimination: support advanced content_taxonomy widgets
    if ($field['module'] == 'content_taxonomy') {
      // this is a case where the #title will be beneath (at $element['tids'])
      $available_props[$group_path_prefix . $field_name]['label'] = $field['widget']['label'];
      
      // known to be handled by cck realm:
      // (i.e. not delegated to taxo realm)
      // - content_taxonomy_options
      // - content_taxonomy_autocomplete
      // known to be delegated to taxo realm:
      $taxo_widgets = array(
        'hs_content_taxonomy',
      );
      // not yet supported by taxo realm:
      // - activeselect
      // - multiselect
      // - content_taxonomy_tree (depends on taxonomy_manager)
      // known to be free tagging
      $free_tagging_widgets = array();
      
      $widget_module = $field['widget']['module'];
      if (in_array($widget_module, $taxo_widgets)) {
        // taxonomy-related widget are gonna be delegated to comment_driven_taxo
        //$hierarchy = ; // @TODO: how to know whether it should be flagged or not
        $multiple = $field['multiple'];
        $tags = in_array($widget_module, $free_tagging_widgets);
        
        // @per-module-discrimination: support hs_content_taxonomy
        if ($widget_module == 'hs_content_taxonomy') {
          // has its own field configuration
          module_load_include('inc', 'hierarchical_select', 'modules/' . $widget_module . '.admin');
          $hs_config_form = hs_content_taxonomy_config_form(array(), $node_type, $field_name);
          $save_lineage = $hs_config_form['hierarchical_select_config']['save_lineage']['#default_value'];
          $drop_box = $hs_config_form['hierarchical_select_config']['dropbox']['status']['#default_value'];
          $multiple = ($save_lineage | $drop_box); 
        }
        
        // additional meta to indicated target vid and voc_override
        $taxo_meta = array(
          'vid' => $field['vid'],
          'voc_override' => array(
            //'hierarchy' => $hierarchy, // @TODO: how to know whether it should be flagged or not
            'multiple' => $multiple,
            'tags' => $tags,
          ),
        );
        $available_props[$group_path_prefix . $field_name]['meta']['taxo_meta'] = $taxo_meta;
        
        // therefore, it will require both realms: cck & taxo
        if (!module_exists('comment_driven_taxo')) {
          $available_props[$group_path_prefix . $field_name]['type_settings'] += array(
            '#description' => t('This property requires %module to be enabled, since it is both CCK & Taxonomy related.', array('%module' => 'comment_driven_taxo')),
            '#disabled' => TRUE,
            '#value' => FALSE,
          );
        }
      }
    }
  }
  
  return $available_props;
}

/**
 * Implements hook_diff_values().
 */
function comment_driven_cck_diff_values($element, $form_values, $meta) {
  extract($meta); // $realm, $property_path, $node_type, $field_name [, $taxo_meta]

  $field = comment_driven_cck_get_field($field_name, $node_type);
  if (!$field) {
    // can't guess, can't normalize $value
    // can't afford being asked for diff_render
    return FALSE; // nothing to declare (i.e. return no diff_values)
  }

  // if values are not at this level pass through it
  // careful, isset is not enough, since it can be NULL (e.g. number)
  // not using in_array, since it compares and matches zero with string
  // @TODO: don't know other way to discriminate cck's number having NULL #default_value
  if (!isset($element['#default_value']) && (!isset($element['#type']) || ($element['#type'] != 'number' || !isset($element['_error_element'])))) {
    if (!count(element_children($element))) {
      // bypass (it should be add_more or something else)
      return FALSE;
    }
    
    // @TODO: FIXME: don't miss extra items added with add_more button
    // remember that $form_values might have more deltas than $element
    // fixes attempts brought other bugs:
    // - re-preview loosing added fields after some idle time
    // - uncontroled _error_element ruining symmetric diff
    // - filling with inplace built empty ala content_set_empty without presave/etc
    foreach (element_children($element) as $key) {
      $diff_values = comment_driven_cck_diff_values($element[$key], $form_values, $meta);
      if (!$diff_values) continue;
      
      list($old, $new) = $diff_values;
      // on diff_render symmetric_diff will drop the keys
      // therefore reseted indexes wouldn't harm here
      // but wouldn't be accurate either (e.g. for debugging)
      $olds[$key] = $old;
      $news[$key] = $new;
    }
    
    if (empty($olds) && empty($news)) return FALSE;
    return array($olds, $news);
  }
  
  // this is done here, since it depends on $field['multiple']
  // which may vary in time (therefore can't be set into $meta at hook_driven_properties)
  // multiple:
  // 0 = FALSE => single value
  // 1 = TRUE => Ulimited => AHAH add_more
  // 2+ = TRUE => Limited
  //
  // see content_field_form
  //
  // If the widget is handling multiple values (e.g optionwidgets),
  // or selecting an individual element, just get a single form
  // element and make it the $delta value.
  //
  // If we're processing a specific delta value for a field where the
  // content module handles multiples, set the delta in the result.
  // For fields that handle their own processing, we can't make assumptions
  // about how the field is structured, just merge in the returned value.
  //
  // @TODO: @per-module-discrimination: "can't make assumptions about how the field is structured"

  $default = $element['#default_value'];
  // $value will be normized if needed (per case basis)
  // to match #default_value format instead of $form_state['values']
  $value = comment_driven_form_get_value($element['#parents'], $form_values);

  // @per-module-discrimination
  switch ($field['type']) {
    case 'filefield':
      // remove from $value keys which are not present in $default
      $keys = array_diff(array_keys($value), array_keys($default));
      foreach ($keys as $key) {
        unset($value[$key]);
      }
      break;
      
    case 'date':
      // doc in _date_widget states:
      // It would seem to make sense to do this conversion when the data
      // is loaded instead of when the form is created, but the loaded
      // field data is cached and we can't cache dates that have been converted
      // to the timezone of an individual user, so we cache the UTC values
      // instead and do our conversion to local dates in the form and
      // in the formatters.
      $timezone = date_get_timezone($field['tz_handling'], isset($default['timezone']) ? $default['timezone'] : date_default_timezone_name());
      $process = date_process_values($field);
      foreach ($process as $processed) {
        if (!isset($value[$processed])) {
          $value[$processed] = '';
        }
        $date = date_local_date(NULL, NULL, NULL, $value, $timezone, $field, $processed);
        $value[$processed] = is_object($date) ? date_format($date, DATE_FORMAT_DATETIME) : '';
      }

      // copy from $default keys which are not present in $value
      $keys = array('timezone_db', 'date_type');
      foreach ($keys as $key) {
        $value[$key] = $default[$key];
      }
      break;
      
    // @per-module-discrimination: support taxonomy-related content_taxonomy widgets
    case 'content_taxonomy':
      if (!empty($taxo_meta)) {
        // delegate to comment_driven_taxo, which knows widget's tweaks
        return comment_driven_taxo_diff_values($element, $form_values, $meta + $taxo_meta);
      }
      break;
  }
  
  $node = (object)array(
    'type' => $node_type, 
    'build_mode' => NODE_BUILD_NORMAL
  );

  // - if it is a single item then it gets here with its proper array
  // - if it is multiple items then it gets here by pieces
  //   being each single item a respective delta, which need to be wrapped into an array
  // - exception: multiple items handled altogether instead of by pieces (e.g. checkboxes)
  
  // discriminate based on whether #default_value is an array of delta=>item
  // or just an direct item (without the wrapper parent)
  $separated_item = !isset($element['#default_value'][$element['#delta']]);
  
  // wrap separated item into items
  if ($separated_item) {
    $default = array($default);
    $value = array($value);
  }
  
  // @per-module-discrimination: support number (decimal)
  // otherwise "string vs double" comparison won't work
  // having non-significant zeros [#461536-2]
  // then normilizing to $value to meet $default_value format
  // would be converting it to string and pad decimal places
  // with zeros as much as scale
  if ($field['type'] == 'number_decimal') {
    foreach ($value as $delta => $item) {
      $val = &$value[$delta]['value'];
      // same treatment as proposed at [#461536-7]
      // Note that it should be a double value (or a string if CCK patch was applied)
      // and its decimal separator will be a dot regarless of the field['decimal'] separator
      list($units, $fraction) = explode('.', $val);
      if (is_null($fraction)) {
        $fraction = '';
      }
      $fraction = str_pad($fraction, $field['scale'], '0');
      $val = $units . '.' . $fraction;
    }
  }
  
  // filter out empty values
  // @TODO: until now it seems that CCK sub-modules doesn't implement their own presave
  content_field('presave', $node, $field, $default, FALSE, TRUE);
  // $value is passed by ref and cleared through content_set_empty
  content_field('presave', $node, $field, $value, FALSE, TRUE);
  
  // @per-module-discrimination: support text (format)
  // in passing by, fix any other module that might come up with the same issue
  // CCK text:
  // a text field can be set with input format
  // even when choosing a widget that won't support it
  // e.g. checkboxes/radios
  // in that case #default_value contains items with
  // 'value' and uninitialized 'format'
  // and marvelous function content_set_empty
  // won't complete the missing columns with NULL
  // it just handles the missing whole items
  foreach ($default as $delta => $item) {
    // the easiest way to iterate over empty valued keys
    foreach (array_keys($default[$delta]) as $key) {
      if (!isset($default[$delta][$key]) && isset($value[$delta]) && !isset($value[$delta][$key])) {
        // nevermind if it was NULL already
        $value[$delta][$key] = NULL; // make it even to #default_value
      }
    }
  }
  
  // unwrap separated item from items
  if ($separated_item) {
    // pick only the first item
    // since remaning items were filled with equivalent empty CCK values
    $default = array_shift($default);
    $value = array_shift($value);
    // dismiss non-value meta
    // '_weight' should come cleared from 'presave' (_content_sort_items)
    // but it won't harm to cover it here as well (just in case)
    unset($value['_weight'], $value['_error_element']);
    
    // @TODO: every call to comment_driven_assertion_failed will be removed after alpha/beta stage 
    if (isset($default['#_error_element'])) comment_driven_assertion_failed('isset($default[\'#_error_element\']) path: ' . implode(':', $element['#array_parents']));
    // clearing $default shouldn't be needed, but it seems it does
    // when AHAH is involved the form might come back with _error_element
    unset($default['_weight'], $default['_error_element']);
  }
  
  // from this point $value is no longer passed by ref
  if (comment_driven_equal_keyed_array_in_depth($default, $value)) return FALSE;
  return array($default, $value);
}

/**
 * Implements hook_diff_render().
 */
function comment_driven_cck_diff_render($old, $new, $meta) {
  extract($meta); // $realm, $property_path, $node_type, $field_name [, $taxo_meta]

  $field = comment_driven_cck_get_field($field_name, $node_type);
  if (!$field) {
    // can't say, but if we got here was because diff_values delivered something
    // (either deliberately or for real in a time the vocabulary existed)
    return array('?', '?');
  }
  
  // @per-module-discrimination: support taxonomy-related content_taxonomy widgets
  if ($field['module'] == 'content_taxonomy' && !empty($taxo_meta)) {
    // delegate to comment_driven_taxo, which knows widget's tweaks
    
    // pass through tids arrays,
    // since cck_diff_value took care of the wrapper
    // but comment_driven_taxo won't be aware of it 
    return comment_driven_taxo_diff_render($old['tids'], $new['tids'], $meta + $taxo_meta);
  }
  
  
  $node = (object)array(
    'type' => $node_type, 
    'build_mode' => NODE_BUILD_NORMAL
  );

  list($old, $new) = comment_driven_symmetric_diff($old, $new);
  
  $function = $field['module'] . '_field';
  if (function_exists($function)) {
    $function('sanitize', $node, $field, $old, FALSE, TRUE);
    $old_view = $function('view', $node, $field, $old, FALSE, TRUE);
    
    $function('sanitize', $node, $field, $new, FALSE, TRUE);
    $new_view = $function('view', $node, $field, $new, FALSE, TRUE);
  }
  // the module might implement hook_field but not  necessarily the 'view' operation 
  if (!isset($old_view)) {
    $old_view = content_field('view', $node, $field, $old, FALSE, TRUE);
    $new_view = content_field('view', $node, $field, $new, FALSE, TRUE);
  }
  
  $outgoing = array();
  $incoming = array();
  $classes = array($field['type'], $field['field_name']);
  // old/new delta don't have to match
  
  foreach ($old_view[$field_name]['field']['items'] as $delta => $item) {
    $rendered = drupal_render($item);
    if (!empty($rendered)) {
      if ($field['multiple']) {
        $rendered = theme('comment_driven_outgoing_diff', $rendered, $classes);
      }
      $outgoing[] = $rendered;
    }
  }
  foreach ($new_view[$field_name]['field']['items'] as $delta => $item) {
    $rendered = drupal_render($item);
    if (!empty($rendered)) {
      if ($field['multiple']) {
        $rendered = theme('comment_driven_incoming_diff', $rendered, $classes);
      }
      $incoming[] = $rendered;
    }
  }
  
  return array($outgoing, $incoming);
}

function comment_driven_cck_get_field($field_name, $node_type) {
  // Gather type information.
  $cck_type = content_types($node_type); // at least returns a virgen field definition
  $fields = $cck_type['fields']; // if virgen it would be an empty array
  if (empty($fields[$field_name])) {
    comment_driven_cck_warn_field_not_found($field_name, $node_type);
    return FALSE;
  }
  return $fields[$field_name];
}

function comment_driven_cck_warn_field_not_found($field_name, $node_type) {
  $details = t('Field %field couldn\'t be fetched for content type %type.', array(
    '%field' => $field_name, 
    '%type' => $node_type,
  ));
  comment_driven_warn_inaccurate_diff($details);
}
