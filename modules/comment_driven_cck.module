<?php
// $Id$

/**
 * Implements hook_driven_properties().
 */
function comment_driven_cck_driven_properties($node_type) {
  $available_props = array();
  
  $prefix = t('CCK') . ' » ';
  
  // according to content_field_overview_form:
  // When displaying the form, make sure the list of fields is up-to-date.
  content_clear_type_cache();
  
  // Gather type information.
  $cck_type = content_types($node_type);
  $fields = $cck_type['fields'];
  $field_types = _content_field_types();
  
  $groups = array();
  if (module_exists('fieldgroup')) {
    $groups = fieldgroup_groups($cck_type['type']);
  }
  
  $grouped_paths = array();
  // first lookup the groups to discriminate nested fields
  foreach ($groups as $group_name => $group) {
    foreach ($group['fields'] as $field_name => $field) {
      $property_paths[$field_name] = $group_name;
    }
  }

  // lookup fields withtout group
  foreach ($fields as $field_name => $field) {
    // pack info for later use
    $meta = compact('node_type', 'field_name');
  
    if (isset($grouped_paths[$field_name])) {
      $group_name = $grouped_paths[$field_name];
      $group_path_prefix = $group_name . ':';
      $group_title_prefix = $group_name . ' » ';
    }
    else {
      $group_name = NULL;
      $group_path_prefix = '';
      $group_title_prefix = '';
    }
    
    $available_props[$group_path_prefix . $field_name] = array(
      'realm' => 'cck',
      'meta' => $meta,
      'type_settings' => array(
        '#title' => $prefix . $group_title_prefix . $field['widget']['label'],
/*
        // the more elemental the lighter
        // (core required: -5, core optional: -2, CCK: 1, CCK submod: 2)
        '#weight' => 1,
*/
      ),
    );
    
    if (!in_array($field['module'], array('userreference', 'nodereference', 'number', 'text', 'optionwidgets'))) {
      $available_props[$group_path_prefix . $field_name]['type_settings'] += array(
        '#description' => t('Pending %module support.', array('%module' => $field['module'])),
        '#disabled' => TRUE,
        '#value' => FALSE,
        '#weight' => 10, // sink
      );
    }
  }
  
  return $available_props;
}

/**
 * Implements hook_diff_values().
 */
function comment_driven_cck_diff_values($element, $form_values, $meta) {
  // $value will be normized by if needed (per case basis)
  // to match #default_value format instead of $form_state['values']
  
  extract($meta); // $node_type, $field_name

  $field = comment_driven_cck_get_field($field_name, $node_type);
  if (!$field) {
    // can't guess, can't normalize $value
    // can't afford being asked for diff_render
    return FALSE; // nothing to declare (i.e. return no diff_values)
  }

  // if values are not at this level go deep through
  if (!isset($element['#default_value'])) {
    if (!count(element_children($element))) {
      // bypass (it should be add_more or something else)
      return FALSE;
    }
    
    foreach (element_children($element) as $key) {
      $diff_values = comment_driven_cck_diff_values($element[$key], $form_values, $meta);
      if (!$diff_values) continue;
      
      list($old, $new) = $diff_values;
      // @TODO: revisit
      // index with $key? (e.g. uid, nid, numeric deltas, etc)
      // (reseted indexes wouldn't harm, but wouldn't be accurate either)
      $olds[] = $old;
      $news[] = $new;
    }
    
    if (empty($olds) && empty($news)) return FALSE;
    return array($olds, $news);
  }
  
  // this is done here, since it depends on $field['multiple']
  // which may vary in time (therefore can't be set into $meta at hook_driven_properties)
  // multiple:
  // 0 = FALSE => single value
  // 1 = TRUE => Ulimited => AHAH add_more
  // 2+ = TRUE => Limited
  //
  // see content_field_form
  //
  // If the widget is handling multiple values (e.g optionwidgets),
  // or selecting an individual element, just get a single form
  // element and make it the $delta value.
  //
  // If we're processing a specific delta value for a field where the
  // content module handles multiples, set the delta in the result.
  // For fields that handle their own processing, we can't make assumptions
  // about how the field is structured, just merge in the returned value.
  //
  // @TODO: @per-module-discrimination: "can't make assumptions about how the field is structured"

  $default = $element['#default_value'];
  // $value will be normized if needed (per case basis)
  // to match #default_value format instead of $form_state['values']
  $value = comment_driven_form_get_value($element['#parents'], $form_values);
  
  $node = (object)array(
    'type' => $node_type, 
    'build_mode' => NODE_BUILD_NORMAL
  );

  // - if it is a single item then it gets here with its proper array
  // - if it is multiple items then it gets here by pieces
  //   being each single item a respective delta, which need to be wrapped into an array
  // - exception: multiple items handled altogether instead of by pieces (e.g. checkboxes)
  
  // discriminate based on whether #default_value is an array of delta=>item
  // or just an direct item (without the wrapper parent)
  $separated_item = !isset($element['#default_value'][$element['#delta']]);
  
  // wrap separated item into items
  if ($separated_item) {
    $default = array($default);
    $value = array($value);
  }
  
  // filter out empty values
  // @TODO: until now it seems that CCK sub-modules doesn't implement their own presave
  content_field('presave', $node, $field, $default, FALSE, TRUE);
  // $value is passed by ref and cleared through content_set_empty
  content_field('presave', $node, $field, $value, FALSE, TRUE);
  
  // @per-module-discrimination: support text (format)
  // in passing by, fix any other module that might come up with the same issue
  // CCK text:
  // a text field can be set with input format
  // even when choosing a widget that won't support it
  // e.g. checkboxes/radios
  // in that case #default_value contains items with
  // 'value' and uninitialized 'format'
  // and marvelous function content_set_empty
  // won't complete the missing columns with NULL
  // it just handles the missing whole items
  foreach ($default as $delta => $item) {
    // the easiest way to iterate over empty valued keys
    foreach (array_keys($default[$delta]) as $key) {
      if (!isset($default[$delta][$key]) && isset($value[$delta]) && !isset($value[$delta][$key])) {
        // nevermind if it was NULL already
        $value[$delta][$key] = NULL; // make it even to #default_value
      }
    }
  }
  
  // unwrap separated item from items
  if ($separated_item) {
    // pick only the first item
    // since remaning items were filled with equivalent empty CCK values
    $default = array_shift($default);
    $value = array_shift($value);
    // dismiss non-value meta
    // '_weight' should come cleared from 'presave' (_content_sort_items)
    // but it won't harm to cover it here as well (just in case)
    unset($value['_weight'], $value['_error_element']);
  }
  
  // from this point $value is no longer passed by ref
  if (comment_driven_equal_keyed_array_in_depth($default, $value)) return FALSE;
  return array($default, $value);
}

/**
 * Implements hook_diff_render().
 */
function comment_driven_cck_diff_render($old, $new, $meta) {
  extract($meta); // $node_type, $field_name

  $field = comment_driven_cck_get_field($field_name, $node_type);
  if (!$field) {
    // can't say, but if we got here was because diff_values delivered something
    // (either deliberately or for real in a time the vocabulary existed)
    return array('?', '?');
  }
  
  $node = (object)array(
    'type' => $node_type, 
    'build_mode' => NODE_BUILD_NORMAL
  );

  list($old, $new) = comment_driven_symmetric_diff($old, $new);
  
  $function = $field['module'] . '_field';
  if (function_exists($function)) {
    $function('sanitize', $node, $field, $old, FALSE, TRUE);
    $old_view = $function('view', $node, $field, $old, FALSE, TRUE);
    
    $function('sanitize', $node, $field, $new, FALSE, TRUE);
    $new_view = $function('view', $node, $field, $new, FALSE, TRUE);
  }
  // the module might implement hook_field but not  necessarily the 'view' operation 
  if (!isset($old_view)) {
    $old_view = content_field('view', $node, $field, $old, FALSE, TRUE);
    $new_view = content_field('view', $node, $field, $new, FALSE, TRUE);
  }
  
  $outgoing = array();
  $incoming = array();
  $classes = array($field['type'], $field['field_name']);
  // old/new delta don't have to match
  
  foreach ($old_view[$field_name]['field']['items'] as $delta => $item) {
    $rendered = drupal_render($item);
    if (!empty($rendered)) {
      if ($field['multiple']) {
        $rendered = theme('comment_driven_outgoing_diff', $rendered, $classes);
      }
      $outgoing[] = $rendered;
    }
  }
  foreach ($new_view[$field_name]['field']['items'] as $delta => $item) {
    $rendered = drupal_render($item);
    if (!empty($rendered)) {
      if ($field['multiple']) {
        $rendered = theme('comment_driven_incoming_diff', $rendered, $classes);
      }
      $incoming[] = $rendered;
    }
  }
  
  return array($outgoing, $incoming);
}

function comment_driven_cck_get_field($field_name, $node_type) {
  // Gather type information.
  $cck_type = content_types($node_type); // at least returns a virgen field definition
  $fields = $cck_type['fields']; // if virgen it would be an empty array
  if (empty($fields[$field_name])) {
    comment_driven_cck_warn_field_not_found($field_name, $node_type);
    return FALSE;
  }
  return $fields[$field_name];
}

function comment_driven_cck_warn_field_not_found($field_name, $node_type) {
  $details = t('Field %field couldn\'t be fetched for content type %type.', array(
    '%field' => $field_name, 
    '%type' => $node_type,
  ));
  comment_driven_warn_inaccurate_diff($details);
}
