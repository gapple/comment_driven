<?php
// $Id$

/**
 * Implements hook_driven_properties().
 */
function comment_driven_cck_driven_properties($node_type) {
  $available_props = array();
  
  // according to content_field_overview_form:
  // When displaying the form, make sure the list of fields is up-to-date.
  content_clear_type_cache();
  
  // Gather type information.
  $cck_type = content_types($node_type);
  $fields = $cck_type['fields'];
  $field_types = _content_field_types();
  
  $groups = array();
  if (module_exists('fieldgroup')) {
    $groups = fieldgroup_groups($cck_type['type']);
  }
  
  // first lookup the groups to discriminate nested fields
  foreach ($groups as $group_name => $group) {
    foreach ($group['fields'] as $field_name => $field) {
      $available_props['cck:' . $group_name . ':' . $field_name] = 'CCK &raquo; ' . $group_name . ' &raquo; ' . $field_name;
      unset($fields[$field_name]);
    }
  }
  
  // lookup fields withtout group
  foreach ($fields as $field_name => $field) {
    $available_props['cck:' . $field_name] = 'CCK &raquo; ' . $field_name;
  }
  
  return $available_props;
}

/**
 * Implements comment_driven_[element_kind]_bypass_property().
 */
function comment_driven_cck_bypass_property($node_type, $element_path, $element) {
  if (!isset($element['#field_name'])) {
    // don't know what could it be, but definitely not the field itself
    // just in case a CCK field implements its own magic (beyond what CCK already does)
    return TRUE;
  }
  // if it is a sub-item then its parent is just an items wrapper
  $separated_item = !isset($element['#default_value'][$element['#delta']]);
  return !$separated_item;
}

/**
 * Implements comment_driven_[element_kind]_equal().
 */
function comment_driven_cck_equal($element, &$value, &$meta = array()) {
  // $value will be normized by if needed (per case basis)
  // to match #default_value format instead of $form_state['values']
  
  $default = $element['#default_value'];
  
  $node_type = $element['#type_name'];
  $field_name = $element['#field_name'];
  // Gather type information.
  $cck_type = content_types($node_type);
  $fields = $cck_type['fields'];
  $field = $fields[$field_name];
  
  $node = (object)array(
    'type' => $node_type, 
    'build_mode' => NODE_BUILD_NORMAL
  );

  // - if it is a single item then it gets here with its proper array
  // - if it is multiple items then it gets here by pieces
  //   being each single item a respective delta, which need to be wrapped into an array
  // - exception: multiple items handled altogether instead of by pieces (e.g. checkboxes)
  
  // discriminate based on whether #default_value is an array of delta=>item
  // or just an direct item (without the wrapper parent)
  $separated_item = !isset($element['#default_value'][$element['#delta']]);
  
  // pack info for render time
  $meta = compact('node_type', 'field_name', 'separated_item');
  
  // wrap separated item into items
  if ($separated_item) {
    $default = array($default);
    $value = array($value);
  }
  
  // filter out empty values
  // @TODO: until now it seems that CCK sub-modules doesn't implement their own presave
  content_field('presave', $node, $field, $default, FALSE, TRUE);
  // $value is passed by ref and cleared through content_set_empty
  content_field('presave', $node, $field, $value, FALSE, TRUE);
  
  // @per-module-discrimination: support text (format)
  // in passing by, fix any other module that might come up with the same issue
  // CCK text:
  // a text field can be set with input format
  // even when choosing a widget that won't support it
  // e.g. checkboxes/radios
  // in that case #default_value contains items with
  // 'value' and uninitialized 'format'
  // and marvelous function content_set_empty
  // won't complete the missing columns with NULL
  // it just handles the missing whole items
  foreach ($default as $delta => $item) {
    // the easiest way to iterate over empty valued keys
    foreach (array_keys($default[$delta]) as $key) {
      if (!isset($default[$delta][$key]) && isset($value[$delta]) && !isset($value[$delta][$key])) {
        // nevermind if it was NULL already
        $value[$delta][$key] = NULL; // make it even to #default_value
      }
    }
  }
  
  // unwrap separated item from items
  if ($separated_item) {
    // pick only the first item
    // since remaning items were filled with equivalent empty CCK values
    $default = array_shift($default);
    $value = array_shift($value);
    // dismiss non-value meta
    // '_weight' should come cleared from 'presave' (_content_sort_items)
    // but it won't harm to cover it here as well (just in case)
    unset($value['_weight'], $value['_error_element']);
  }
  
  // $value is no longer passed by ref
  return _comment_driven_equal_keyed_array_in_depth($default, $value);
}

/**
 * Implements comment_driven_[element_kind]_label().
 */
//function comment_driven_cck_label($element, $parents_titles) {
//  return comment_driven_first_title($element, $parents_titles);
//}

/**
 * Implements comment_driven_[element_kind]_render_diff().
 */
function comment_drivent_cck_render_diff($old, $new, $meta) {
  // unpack info: $node_type, $field_name, $separated_item
  extract($meta);
  
  // Gather type information.
  $cck_type = content_types($node_type);
  $fields = $cck_type['fields'];
  $field = $fields[$field_name];
  
  $node = (object)array(
    'type' => $node_type, 
    'build_mode' => NODE_BUILD_NORMAL
  );

  // wrap separated item into items
  if ($separated_item) {
    $old = array($old);
    $new = array($new);
  }
  
  list($old, $new) = comment_driven_symmetric_diff($old, $new);
  
  $function = $field['module'] . '_field';
  if (function_exists($function)) {
    $old_view = $function('view', $node, $field, $old, FALSE, TRUE);
    $new_view = $function('view', $node, $field, $new, FALSE, TRUE);
  }
  // the module might implement hook_field but not  necessarily the 'view' operation 
  if (!isset($old_view)) {
    $old_view = content_field('view', $node, $field, $old, FALSE, TRUE);
    $new_view = content_field('view', $node, $field, $new, FALSE, TRUE);
  }
  
  $old_rendered = array();
  $new_rendered = array();
  $classes = array($field['type'], $field['field_name']);
  // old/new delta don't have to match
  foreach ($old_view[$field_name]['field']['items'] as $delta => $item) {
    $rendered = drupal_render($item);
    if (!empty($rendered)) {
      if ($field['multiple']) $rendered = theme('comment_driven_outgoing_diff', $rendered, $classes);
      $old_rendered[] = $rendered;
    }
  }
  foreach ($new_view[$field_name]['field']['items'] as $delta => $item) {
    $rendered = drupal_render($item);
    if (!empty($rendered)) {
      if ($field['multiple']) $rendered = theme('comment_driven_incoming_diff', $rendered, $classes);
      $new_rendered[] = $rendered;
    }
  }
  
  return array($old_rendered, $new_rendered);
}
