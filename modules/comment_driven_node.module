<?php
// $Id$

/**
 * Implements hook_driven_properties().
 */
function comment_driven_node_driven_properties($node_type) {
  $prefix = t('Node') . ' &raquo; ';
  $available_props = array(
    'node:title' => $prefix . t('Title'),
    // body_field:body, body_field:format, body_field:teaser_include, body_field:teaser_js
    'node:body_field' => $prefix . t('Body'),
    'node:options:status' => $prefix . t('Published'), 
    'node:options:promote' => $prefix . t('Promoted to front page'), 
    'node:options:sticky' => $prefix . t('Sticky at top of lists'), 
    'node:comment_settings' => $prefix . t('Comment settings'),
    // revision info makes no sence, since it isn't a node property (and always starts being empty)
    //'node:revision_information:log' => $prefix . t('Revision log message'),
  );
  return $available_props;
}

/**
 * Implements comment_driven_[element_kind]_bypass_property().
 */
function comment_driven_node_bypass_property($node_type, $element_path, $element) {
  // @TODO: every call to comment_driven_assertion_failed will be removed after alpha/beta stage 
  if ($element['#type'] == 'textarea' && $element_path != 'body_field:body') comment_driven_assertion_failed('unknown #type=textarea at: ' . $element_path);

  // there is body_field with body, format, js_teaser, js_include beneath
  return ($element['#type'] != 'textarea');
}

/**
 * Implements comment_driven_[element_kind]_label().
 */
//function comment_driven_node_label($element, $parents_titles) {
//  return comment_driven_first_title($element, $parents_titles);
//}

/**
 * Implements comment_driven_[element_kind]_equal().
 */
function comment_driven_node_equal($element, &$value, &$meta = array()) {
  // @TODO: consider body_field:format as well as CCK text does
  return _comment_driven_equal_non_array($element, $value); 
}

/**
 * Implements comment_driven_[element_kind]_render_diff().
 */
function comment_drivent_node_render_diff($old, $new, $meta) {
  // @TODO: some $meta might come handy
  // even for body_field:format, for publishing checkboxes, comment settings radios, etc
  // @TODO FIXME: sanitize body_field according ot its input format
  // @TODO: will need to trim the body_field somehow
  if (is_string($old)) $old = check_plain($old);
  if (is_string($new)) $new = check_plain($new);
  return array($old, $new); // @TODO FIXME: temporal (should discriminate the type of value, i.e. checkbox, radio, textfield, textarea!, etc)
}
