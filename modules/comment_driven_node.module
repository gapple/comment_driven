<?php
// $Id$

/**
 * Implements hook_driven_properties().
 */
function comment_driven_node_driven_properties($node_type) {
  $available_props = array();

  $prefix = t('Node') . ' » ';
  
  $available_props['title'] = array(
    'realm' => 'node',
    'type_settings' => array(
      '#title' => $prefix . t('Title'),
    ),
  );
  
  // @TODO: review
  $label = node_get_types('type', $node_type)->body_label;
  // body_field:body, body_field:format,
  // body_field:teaser_include, body_field:teaser_js
  $available_props['body_field'] = array(
    'realm' => 'node',
    'label' => $label,
    // request to include non changed children
    // if at least one of them changed
    // since all of them will be needed at diff_render time
    'meta' => array('wrapper_joint' => TRUE),
    'type_settings' => array(
      '#title' => $prefix . t('Body'),
    ),
  );
  
  $theme = 'comment_driven_yes_no';
  $available_props['options:status'] = array(
    'realm' => 'node',
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . t('Published'),
    ),
  );
  
  $label = t('Promoted');
  $theme = 'comment_driven_yes_no';
  $available_props['options:promote'] = array(
    'realm' => 'node',
    'label' => $label, // default would be: 'Promoted to front page'
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . $label,
    ),
  );
  
  $label = t('Sticky');
  $theme = 'comment_driven_yes_no';
  $available_props['options:sticky'] = array(
    'realm' => 'node',
    'label' => $label, // default would be: 'Sticky at top of lists'
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . $label,
    ),
  );
  
  $theme = 'comment_driven_node_comment_settings';
  $available_props['comment_settings'] = array(
    'realm' => 'node',
    'label' => t('Comments'), // default would be: 'Comment settings'
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . t('Comment settings'),
    ),
  );
  
  $theme = 'comment_driven_username';
  $available_props['author:name'] = array(
    'realm' => 'node',
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . t('Authored by'),
    ),
  );
  
  $available_props['author:date'] = array(
    'realm' => 'node',
    'type_settings' => array(
      '#title' => $prefix . t('Authored on'),
    ),
  );
  
  // revision info makes no sence, since it isn't a node property
  // it always starts being empty log with a checkbox following content type settings
  // therefore, changing them would always display the same old value
  // and the new value will be accurate, but next change will reflect
  // coming from same status than its precedents...
  /*
  $label = t('New revision');
  $theme = 'comment_driven_yes_no';
  $available_props['revision_information:revision'] = array(
    'realm' => 'node',
    'label' => $label, // default would be: 'Create new revision'
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . t('Revision') . ' » ' . $label,
    ),
  );
  
  $available_props['revision_information:log'] = array(
    'realm' => 'node',
    'label' => t('Revision log'), // default would be: 'Log message'
    'type_settings' => array(
      '#title' => $prefix . t('Revision') . ' » ' . t('Log'),
    ),
  );
  */
  
/*
  foreach ($available_props as $property_path => &$prop) {
    // the more elemental the lighter
    // (core required: -5, core optional: -2, CCK: 1, CCK submod: 2)
    $prop['type_settings']['#weight'] = -5;
  }
*/
  
  return $available_props;
}

/**
 * Implements hook_diff_values().
 */
function comment_driven_node_diff_values($element, $form_values, $meta) {
  extract($meta); // $realm, $property_path, $theme
  
  $default = comment_driven_known_default_value($element);
  // $value will be normized if needed (per case basis)
  // to match #default_value format instead of $form_state['values']
  $value = comment_driven_form_get_value($element['#parents'], $form_values);
  
  // @TODO: consider body_field:format as well as CCK text does
  if (_comment_driven_equal_non_array($default, $value)) return FALSE;
  return array($default, $value); 
}

/**
 * Implements hook_diff_render().
 */
function comment_driven_node_diff_render($old, $new, $meta) {
  extract($meta); // $realm, $property_path, $theme
  
  // the only special case known
  if ($property_path === 'body_field') {
    // @TODO: do something to display format changes, 
    // might be achieved having diff_render as a triplet
    // with 3rd item being a flag for
    // potentials visually imperceptible changes
    // which for instance would be true if only a format change happened
    // indicating that it might not be a visual difference
    // or FALSE if everything is being rendered (which does NOT mean they can't render the same)
    // @TODO: also consider teaser_include?
    // @TODO: will need to trim the body_field somehow
    // also support other text input for other modules wishing to delegate?
    $outgoing = check_markup($old['body'], $old['format'], TRUE);
    $incoming = check_markup($new['body'], $new['format'], TRUE);
    return array($outgoing, $incoming);
  }
  
  // not particulary interested on a symmetric diff for any case (until now)
  
  if (isset($theme)) {
    $outgoing = theme($theme, $old);
    $incoming = theme($theme, $new);
  }
  else {
    $outgoing = check_plain($old);
    $incoming = check_plain($new);
  }
  return array($outgoing, $incoming);
}

/**
 * Implementation of hook_theme()
 */
function comment_driven_node_theme() {
  return array(
    'comment_driven_node_comment_settings' => array(
      'arguments' => array('flag' => ''),
    ),
  );
}

function theme_comment_driven_node_comment_settings($flag) {
  // @TODO: temporary making it receive the same array saved by diff_values
  $flag = array_shift($flag); // not sure if it would worth unwrapping comment settings at diff_values
  switch ($flag) {
    case 0:
      $meaning = t('Disabled');
      $class = 'disabled';
      break;
    case 1:
      $meaning = t('Read only');
      $class = 'read-only';
      break;
    case 2:
      $meaning = t('Read/Write');
      $class = 'read-write';
      break;
  }
  return '<span class="comment-settings ' . $class . '">' . $meaning . '</span>';
}
