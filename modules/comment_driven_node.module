<?php
// $Id$

/**
 * Implements hook_driven_properties().
 */
function comment_driven_node_driven_properties($node_type) {
  $available_props = array();

  $prefix = t('Node') . ' » ';
  
  $available_props['title'] = array(
    'realm' => 'node',
    'type_settings' => array(
      '#title' => $prefix . t('Title'),
    ),
  );
  
  // @TODO: review
  $label = node_get_types('type', $node_type)->body_label;
  // body_field:body, body_field:format,
  // body_field:teaser_include, body_field:teaser_js
  $available_props['body_field'] = array(
    'realm' => 'node',
    'label' => $label,
    'type_settings' => array(
      '#title' => $prefix . t('Body'),
    ),
  );
  
  $theme = 'comment_driven_yes_no';
  $available_props['options:status'] = array(
    'realm' => 'node',
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . t('Published'),
    ),
  );
  
  $label = t('Promoted');
  $theme = 'comment_driven_yes_no';
  $available_props['options:promote'] = array(
    'realm' => 'node',
    'label' => $label, // default would be: 'Promoted to front page'
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . $label,
    ),
  );
  
  $label = t('Sticky');
  $theme = 'comment_driven_yes_no';
  $available_props['options:sticky'] = array(
    'realm' => 'node',
    'label' => $label, // default would be: 'Sticky at top of lists'
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . $label,
    ),
  );
  
  $theme = 'comment_driven_node_comment_settings';
  $available_props['comment_settings'] = array(
    'realm' => 'node',
    'label' => t('Comments'), // default would be: 'Comment settings'
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . t('Comment settings'),
    ),
  );
  
  $theme = 'comment_driven_username';
  $available_props['author:name'] = array(
    'realm' => 'node',
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . t('Authored by'),
    ),
  );
  
  $available_props['author:date'] = array(
    'realm' => 'node',
    'type_settings' => array(
      '#title' => $prefix . t('Authored on'),
    ),
  );
  
  // revision info makes no sence, since it isn't a node property
  // it always starts being empty log with a checkbox following content type settings
  // therefore, changing them would always display the same old value
  // and the new value will be accurate, but next change will reflect
  // coming from same status than its precedents...
  /*
  $label = t('New revision');
  $theme = 'comment_driven_yes_no';
  $available_props['revision_information:revision'] = array(
    'realm' => 'node',
    'label' => $label, // default would be: 'Create new revision'
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . t('Revision') . ' » ' . $label,
    ),
  );
  
  $available_props['revision_information:log'] = array(
    'realm' => 'node',
    'label' => t('Revision log'), // default would be: 'Log message'
    'type_settings' => array(
      '#title' => $prefix . t('Revision') . ' » ' . t('Log'),
    ),
  );
  */
  
/*
  foreach ($available_props as $property_path => &$prop) {
    // the more elemental the lighter
    // (core required: -5, core optional: -2, CCK: 1, CCK submod: 2)
    $prop['type_settings']['#weight'] = -5;
  }
*/
  
  return $available_props;
}

/**
 * Implements hook_diff_values().
 */
function comment_driven_node_diff_values($element, $form_values, $meta) {
  extract($meta); // $realm, $property_path, $theme
  
  // if values are not at this level pass through it
  // careful, isset is not enough, since it can be NULL
  // not using in_array, since it compares and matches zero with string
  if (!comment_driven_has_default_value_key($element)) {
    if (!count(element_children($element))) {
      // bypass (it should be a wrapper or something else)
      return FALSE;
    }
  
    // @TODO: why WAS this above checking for !count(element_children($element)) ??
    if ($element['#parents'][0] == 'body_field') {
      return _comment_driven_node_diff_body($element, $form_values, $meta);
    }
    
    foreach (element_children($element) as $key) {
      $diff_values = comment_driven_node_diff_values($element[$key], $form_values, $meta);
      if (!$diff_values) continue;
      
      list($old, $new) = $diff_values;
      // on diff_render symmetric_diff will drop the keys
      // therefore reseted indexes wouldn't harm here
      // but wouldn't be accurate either (e.g. for debugging)
      $olds[$key] = $old;
      $news[$key] = $new;
    }
    
    if (empty($olds) && empty($news)) return FALSE;
    return array($olds, $news);
  }
  
  $default = $element['#default_value'];
  // $value will be normized if needed (per case basis)
  // to match #default_value format instead of $form_state['values']
  $value = comment_driven_form_get_value($element['#parents'], $form_values);
  
  // @TODO: consider body_field:format as well as CCK text does
  if (_comment_driven_equal_non_array($default, $value)) return FALSE;
  return array($default, $value); 
}

/**
 * Implements hook_diff_render().
 */
function comment_driven_node_diff_render($old, $new, $meta) {
  extract($meta); // $realm, $property_path, $theme
  
  if (is_array($old)) {
    // is important to check is_array($old)
    // because if it is string the key will evaluate to zero
    // and the first char in the $old string would be returned
    if (isset($old['body'])) {
      // @TODO: do something to display format changes, also consider teaser_include
      // @TODO: will need to trim the body_field somehow
      // also support other text input for other modules wishing to delegate?
      $outgoing = check_markup($old['body'], $old['format'], TRUE);
      $incoming = check_markup($new['body'], $new['format'], TRUE);
      return array($outgoing, $incoming);
    }
  }
  
  // not particulary interested on a symmetric diff for any case (until now)
  
  if (isset($theme)) {
    $outgoing = theme($theme, $old);
    $incoming = theme($theme, $new);
  }
  else {
    $outgoing = check_plain($old);
    $incoming = check_plain($new);
  }
  return array($outgoing, $incoming);
}

/**
 * Implementation of hook_theme()
 */
function comment_driven_node_theme() {
  return array(
    'comment_driven_node_comment_settings' => array(
      'arguments' => array('flag' => ''),
    ),
  );
}

function _comment_driven_node_diff_body($element, $form_values, $meta) {
  $key = 'body';
  $old[$key] = $element[$key]['#default_value'];
  $new[$key] = $form_values[$key];
  $key = 'teaser_include';
  $old[$key] = $element[$key]['#default_value'];
  $new[$key] = $form_values[$key];
  
  // every format has the same #default_value, just pick one
  $key = 'format';
  $index = array_shift(element_children($element[$key]));
  $old[$key] = $element[$key][$index]['#default_value'];
  $new[$key] = $form_values[$key];
  // ignore body_field:teaser_js, since it gets into body in node_teaser_js
  
  // format and teaser_include need to be normalized as non-array values
  // therefore, shouldn't compare them as array (not keyed nor values)
  // normalize $new values to match #default_value format
  $keys = array('body', 'format', 'teaser_include');
  // won't break the loop at first sight, since we are normalizing
  // all the three values passing $new[$key] by ref 
  $equal = array();
  foreach ($keys as $key) {
    $equal[$key] = _comment_driven_equal_non_array($old[$key], $new[$key]);
  }
  
  if ($equal['body'] && $equal['format'] && $equal['teaser_include']) return FALSE;
  return array($old, $new);
}

function theme_comment_driven_node_comment_settings($flag) {
  // @TODO: temporary making it receive the same array saved by diff_values
  $flag = array_shift($flag); // not sure if it would worth unwrapping comment settings at diff_values
  switch ($flag) {
    case 0:
      $meaning = t('Disabled');
      $class = 'disabled';
      break;
    case 1:
      $meaning = t('Read only');
      $class = 'read-only';
      break;
    case 2:
      $meaning = t('Read/Write');
      $class = 'read-write';
      break;
  }
  return '<span class="comment-settings ' . $class . '">' . $meaning . '</span>';
}
