<?php
// $Id$

/**
 * Implements hook_driven_properties().
 */
function comment_driven_node_driven_properties($node_type) {
  $available_props = array();

  $prefix = t('Node') . ' » ';
  
  $available_props['title'] = array(
    'realm' => 'node',
    'type_settings' => array(
      '#title' => $prefix . t('Title'),
    ),
  );
  
  // body_field:body, body_field:format,
  // body_field:teaser_include, body_field:teaser_js
  $formatted_text = array(
    'text' => 'body',
    'format' => 'format',
  );
  $available_props['body_field'] = array(
    'realm' => 'node',
    'meta' => compact('formatted_text'),
    'exclude' => array('teaser_include', 'teaser_js'), // @TODO: revisit
    'type_settings' => array(
      '#title' => $prefix . t('Body'),
    ),
  );
  
  $theme = 'comment_driven_yes_no';
  $available_props['options:status'] = array(
    'realm' => 'node',
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . t('Published'),
    ),
  );
  
  $label = t('Promoted');
  $theme = 'comment_driven_yes_no';
  $available_props['options:promote'] = array(
    'realm' => 'node',
    'label' => $label, // default would be: 'Promoted to front page'
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . $label,
    ),
  );
  
  $label = t('Sticky');
  $theme = 'comment_driven_yes_no';
  $available_props['options:sticky'] = array(
    'realm' => 'node',
    'label' => $label, // default would be: 'Sticky at top of lists'
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . $label,
    ),
  );
  
  $available_props['comment_settings'] = array(
    'realm' => 'node',
    'label' => t('Comments'), // default would be: 'Comment settings'
    'type_settings' => array(
      '#title' => $prefix . t('Comment settings'),
    ),
  );
  
  $theme = 'comment_driven_username';
  $available_props['authored:name'] = array(
    'realm' => 'node',
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . t('Authored by'),
    ),
  );
  
  $available_props['authored:date'] = array(
    'realm' => 'node',
    'type_settings' => array(
      '#title' => $prefix . t('Authored on'),
    ),
  );
  
  // revision info makes no sence, since it isn't a node property
  // it always starts being empty log with a checkbox following content type settings
  // therefore, changing them would always display the same old value
  // and the new value will be accurate, but next change will reflect
  // coming from same status than its precedents...
  /*
  $label = t('New revision');
  $theme = 'comment_driven_yes_no';
  $available_props['revision_information:revision'] = array(
    'realm' => 'node',
    'label' => $label, // default would be: 'Create new revision'
    'meta' => compact('theme'),
    'type_settings' => array(
      '#title' => $prefix . t('Revision') . ' » ' . $label,
    ),
  );
  
  $available_props['revision_information:log'] = array(
    'realm' => 'node',
    'label' => t('Revision log'), // default would be: 'Log message'
    'type_settings' => array(
      '#title' => $prefix . t('Revision') . ' » ' . t('Log'),
    ),
  );
  */
  
/*
  foreach ($available_props as $property_path => &$prop) {
    // the more elemental the lighter
    // (core required: -5, core optional: -2, CCK: 1, CCK submod: 2)
    $prop['type_settings']['#weight'] = -5;
  }
*/
  
  return $available_props;
}

/**
 * Implements hook_bypass_property().
 */
function comment_driven_node_bypass_property($node_type, $element_path, $element) {
  // @TODO: every call to comment_driven_assertion_failed will be removed after alpha/beta stage 
  if ($element['#type'] == 'textarea' && $element_path != 'body_field:body') comment_driven_assertion_failed('unknown #type=textarea at: ' . $element_path);

  // there is body_field with body, format, js_teaser, js_include beneath
  return ($element['#type'] != 'textarea');
}

/**
 * Implements hook_label().
 */
//function comment_driven_node_label($element, $parents_titles) {
//  return comment_driven_first_title($element, $parents_titles);
//}

/**
 * Implements hook_equal_values().
 */
function comment_driven_node_equal_values($element, &$value, &$meta = array()) {
  // @TODO: consider body_field:format as well as CCK text does
  return _comment_driven_equal_non_array($element, $value); 
}

/**
 * Implements hook_diff_render().
 */
function comment_drivent_node_render_diff($old, $new, $meta) {
  // @TODO: some $meta might come handy
  // even for body_field:format, for publishing checkboxes, comment settings radios, etc
  // @TODO FIXME: sanitize body_field according ot its input format
  // @TODO: will need to trim the body_field somehow
  if (is_string($old)) $old = check_plain($old);
  if (is_string($new)) $new = check_plain($new);
  return array($old, $new); // @TODO FIXME: temporal (should discriminate the type of value, i.e. checkbox, radio, textfield, textarea!, etc)
}
